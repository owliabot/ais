schema: "ais/0.0.2"

meta:
  protocol: "uniswap-v3"
  version: "0.0.2"
  name: "Uniswap V3"
  homepage: "https://uniswap.org"
  description: "Swap via Uniswap V3 router with quote-based minOut"
  tags: ["dex", "swap", "liquidity", "amm"]
  maintainer: "uniswap.eth"

capabilities_required:
  - "cel_v1"
  - "evm_read"
  - "evm_call"
  - "detect:best_quote"

deployments:
  - chain: "eip155:1"
    contracts:
      router: "0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45"
      quoter: "0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6"
      factory: "0x1F98431c8aD98523631AE4a59f267346ea31F984"
      position_manager: "0xC36442b4a4522E871399CD717aBDD847Ab11FE88"

  - chain: "eip155:8453"
    contracts:
      router: "0x2626664c2603336E57B271c5C0b26F421741e481"
      quoter: "0x3d4e44Eb1374240CE5F1B871ab261CD16335B76a"
      factory: "0x33128a8fC17869897dcE68Ed026d694621f6FDfD"
      position_manager: "0x03a520b32C04BF3bEEf7BEb72E919cf822Ed34f1"

  - chain: "eip155:42161"
    contracts:
      router: "0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45"
      quoter: "0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6"
      factory: "0x1F98431c8aD98523631AE4a59f267346ea31F984"
      position_manager: "0xC36442b4a4522E871399CD717aBDD847Ab11FE88"

supported_assets:
  - symbol: "WETH"
    name: "Wrapped Ether"
    decimals:
      eip155:1: 18
      eip155:8453: 18
      eip155:42161: 18
    addresses:
      eip155:1: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"
      eip155:8453: "0x4200000000000000000000000000000000000006"
      eip155:42161: "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1"
    tags: ["wrapped"]

  - symbol: "USDC"
    name: "USD Coin"
    decimals:
      eip155:1: 6
      eip155:8453: 6
      eip155:42161: 6
    addresses:
      eip155:1: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
      eip155:8453: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"
      eip155:42161: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831"
    tags: ["stable"]

risks:
  - level: "warning"
    text: "Swaps are exposed to price movement and MEV. Use slippage limits and consider private tx routing."
    applies_to: ["swap-exact-in"]

actions:
  swap-exact-in:
    description: "Swap exact input amount for as much output as possible with quote-based minOut."
    risk_level: 3
    risk_tags: ["mev_exposure", "slippage", "approval"]

    params:
      - name: token_in
        type: asset
        description: "Input token asset"
      - name: token_out
        type: asset
        description: "Output token asset"
      - name: amount_in
        type: token_amount
        description: "Human input amount for token_in"
        asset_ref: "token_in"
      - name: slippage_bps
        type: uint32
        description: "Max slippage in basis points, e.g. 50 = 0.5%"
        default: "50"
        constraints:
          min: 1
          max: 2000
      - name: fee
        type: uint32
        description: "Uniswap V3 fee tier, e.g. 500, 3000"
        required: false
      - name: recipient
        type: address
        description: "Recipient of token_out (defaults to sender)"
        required: false

    requires_queries:
      - "quote-exact-in-single"
      - "allowance-token-in"

    hard_constraints:
      max_slippage_bps: { ref: "params.slippage_bps" }
      allow_unlimited_approval: { lit: false }

    calculated_fields:
      amount_in_atomic:
        expr: { cel: "to_atomic(params.amount_in, params.token_in)" }
        inputs: ["params.amount_in", "params.token_in"]
      recipient:
        expr: { cel: "params.recipient != null ? params.recipient : ctx.wallet_address" }
        inputs: ["params.recipient", "ctx.wallet_address"]
      fee_tier:
        expr:
          detect:
            kind: "best_quote"
            candidates:
              - { lit: "100" }
              - { lit: "500" }
              - { lit: "3000" }
              - { lit: "10000" }
            constraints:
              prefer_liquidity: true
        inputs: []
      deadline_unix:
        expr: { cel: "ctx.now + 600" }
        inputs: ["ctx.now"]
      min_out_atomic:
        expr: { cel: "mul_div(query[\"quote-exact-in-single\"].amount_out_atomic, (10000 - params.slippage_bps), 10000)" }
        inputs: ["query.quote-exact-in-single.amount_out_atomic", "params.slippage_bps"]
      approval_amount_atomic:
        expr: { cel: "calculated.amount_in_atomic" }
        inputs: ["calculated.amount_in_atomic"]

    execution:
      "eip155:*":
        type: composite
        steps:
          - id: approve_if_needed
            description: "Approve router to spend token_in if allowance insufficient"
            condition: { cel: "query[\"allowance-token-in\"].allowance_atomic < calculated.amount_in_atomic" }
            execution:
              type: evm_call
              to: { ref: "params.token_in.address" }
              abi:
                type: "function"
                name: "approve"
                inputs:
                  - { name: "spender", type: "address" }
                  - { name: "amount", type: "uint256" }
                outputs: []
              args:
                spender: { ref: "contracts.router" }
                amount: { ref: "calculated.approval_amount_atomic" }

          - id: swap
            description: "Execute exactInputSingle swap"
            execution:
              type: evm_call
              to: { ref: "contracts.router" }
              abi:
                type: "function"
                name: "exactInputSingle"
                inputs:
                  - name: "params"
                    type: "tuple"
                    components:
                      - { name: "tokenIn", type: "address" }
                      - { name: "tokenOut", type: "address" }
                      - { name: "fee", type: "uint24" }
                      - { name: "recipient", type: "address" }
                      - { name: "deadline", type: "uint256" }
                      - { name: "amountIn", type: "uint256" }
                      - { name: "amountOutMinimum", type: "uint256" }
                      - { name: "sqrtPriceLimitX96", type: "uint160" }
                outputs: []
              args:
                params:
                  object:
                    tokenIn: { ref: "params.token_in.address" }
                    tokenOut: { ref: "params.token_out.address" }
                    fee: { ref: "calculated.fee_tier" }
                    recipient: { ref: "calculated.recipient" }
                    deadline: { ref: "calculated.deadline_unix" }
                    amountIn: { ref: "calculated.amount_in_atomic" }
                    amountOutMinimum: { ref: "calculated.min_out_atomic" }
                    sqrtPriceLimitX96: { lit: "0" }

queries:
  quote-exact-in-single:
    description: "Quote output for exact input single hop"
    params:
      - name: token_in
        type: asset
        description: "Input token asset"
      - name: token_out
        type: asset
        description: "Output token asset"
      - name: amount_in
        type: token_amount
        description: "Human amount for token_in"
        asset_ref: "token_in"
      - name: fee
        type: uint32
        description: "Optional fee tier (auto-detected if not provided)"
        required: false

    returns:
      - name: amount_out_atomic
        type: uint256
        description: "Quoted output amount in token_out atomic units"

    cache_ttl: 3
    consistency:
      block_tag: "latest"
      require_same_block: true

    execution:
      "eip155:*":
        type: evm_read
        to: { ref: "contracts.quoter" }
        abi:
          type: "function"
          name: "quoteExactInputSingle"
          inputs:
            - { name: "tokenIn", type: "address" }
            - { name: "tokenOut", type: "address" }
            - { name: "fee", type: "uint24" }
            - { name: "amountIn", type: "uint256" }
            - { name: "sqrtPriceLimitX96", type: "uint160" }
          outputs:
            - { name: "amount_out_atomic", type: "uint256" }
        args:
          tokenIn: { ref: "params.token_in.address" }
          tokenOut: { ref: "params.token_out.address" }
          fee:
            detect:
              kind: "best_quote"
              candidates:
                - { lit: "100" }
                - { lit: "500" }
                - { lit: "3000" }
                - { lit: "10000" }
              constraints:
                prefer_liquidity: true
          amountIn: { cel: "to_atomic(params.amount_in, params.token_in)" }
          sqrtPriceLimitX96: { lit: "0" }

  allowance-token-in:
    description: "Read token_in allowance for router"
    params:
      - name: token_in
        type: asset
        description: "Input token asset"

    returns:
      - name: allowance_atomic
        type: uint256
        description: "Allowance in token_in atomic units"

    cache_ttl: 10
    execution:
      "eip155:*":
        type: evm_read
        to: { ref: "params.token_in.address" }
        abi:
          type: "function"
          name: "allowance"
          inputs:
            - { name: "owner", type: "address" }
            - { name: "spender", type: "address" }
          outputs:
            - { name: "allowance_atomic", type: "uint256" }
        args:
          owner: { ref: "ctx.wallet_address" }
          spender: { ref: "contracts.router" }

tests:
  - name: "swap-basic-eth-usdc"
    action: "swap-exact-in"
    params:
      token_in:
        chain_id: "eip155:8453"
        address: "0x4200000000000000000000000000000000000006"
        decimals: 18
      token_out:
        chain_id: "eip155:8453"
        address: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"
        decimals: 6
      amount_in: "1.0"
      slippage_bps: "50"
    expect:
      calculated:
        amount_in_atomic: "1000000000000000000"
      execution_type: "composite"
